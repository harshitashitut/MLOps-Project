# name: Frontend CI

# on:
#   push:
#     branches: [ main, develop, feature/** ]
#     paths:
#       - 'frontend/**'
#       - '.github/workflows/frontend-ci.yml'
#   pull_request:
#     branches: [ main ]

# jobs:
#   build-and-test:
#     name: Build & Test Frontend
#     runs-on: ubuntu-latest
    
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3
      
#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v2
      
#       - name: Build Docker image
#         run: |
#           cd frontend
#           docker build -t pitchquest-frontend:test .
      
#       - name: Test Docker image starts
#         run: |
#           docker run -d --name test-frontend -p 3000:80 \
#             pitchquest-frontend:test
          
#           sleep 10
          
#           # Test frontend serves content
#           curl -f http://localhost:3000 || exit 1
          
#           docker stop test-frontend
#           docker rm test-frontend
      
#       - name: Success
#         run: echo "‚úÖ Frontend Docker build successful!"



# ============================================
# FRONTEND CI WORKFLOW
# Purpose: Automatically test and build frontend whenever code changes
# ============================================

# name: Frontend CI

# # ============================================
# # TRIGGERS: When does this workflow run?
# # ============================================
# on:
#   push:
#     # Run when code is pushed to these branches
#     branches: [ main, develop, feature/** ]
#     # But ONLY if these files/folders changed
#     paths:
#       - 'frontend/**'                          # Any file in frontend folder
#       - '.github/workflows/frontend-ci.yml'    # Or this workflow file itself
  
#   pull_request:
#     # Also run on Pull Requests to main
#     branches: [ main ]
#     paths:
#       - 'frontend/**'

# # ============================================
# # JOBS: What tasks to run?
# # ============================================
# jobs:
#   # --------------------------------------------
#   # JOB 1: Build and Test Frontend
#   # --------------------------------------------
#   build-and-test:
#     name: Build & Test Frontend
#     runs-on: ubuntu-latest    # Use GitHub's Ubuntu machine
    
#     steps:
#       # STEP 1: Get the code from GitHub
#       - name: Checkout code
#         uses: actions/checkout@v3
#         # What this does: Downloads your repo to the test machine
#         # Like running: git clone https://github.com/your-repo
      
#       # STEP 2: Install Docker tools
#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v2
#         # What this does: Installs Docker with advanced features
#         # Allows building multi-platform images, caching, etc.
      
#       # STEP 3: Build the Docker image
#       - name: Build Docker image
#         run: |
#           cd frontend
#           docker build -t pitchquest-frontend:test .
#         # What this does: 
#         # - Goes into frontend folder
#         # - Runs: docker build (like docker compose up --build)
#         # - Tags image as "pitchquest-frontend:test"
#         # - Uses the Dockerfile in frontend/
#         #
#         # This catches:
#         # ‚úÖ Missing files (like supabase.js)
#         # ‚úÖ Dockerfile syntax errors
#         # ‚úÖ Build dependency issues
#         # ‚úÖ npm build failures
      
#       # STEP 4: Test that the container actually works
#       - name: Test Docker image starts
#         run: |
#           # Start the container in background (-d)
#           docker run -d --name test-frontend -p 3000:80 \
#             pitchquest-frontend:test
          
#           # Give it time to start (nginx is fast but let's be safe)
#           echo "Waiting for frontend to start..."
#           sleep 30
          
#           # Try to access the frontend
#           # -f flag means "fail if HTTP error"
#           echo "Testing if frontend is serving content..."
#           curl -f http://localhost:3000 || exit 1
          
#           # If we get here, it worked! Clean up.
#           echo "‚úÖ Frontend is responding!"
#           docker stop test-frontend
#           docker rm test-frontend
#         # What this does:
#         # - Starts your frontend container
#         # - Waits 10 seconds
#         # - Tries to fetch the homepage
#         # - If it fails (404, 500, can't connect), CI fails
#         # - If it succeeds, cleans up the container
#         #
#         # This catches:
#         # ‚úÖ Container crashes on startup
#         # ‚úÖ Nginx misconfiguration
#         # ‚úÖ Missing build files
#         # ‚úÖ Port issues
      
#       # STEP 5: Success message
#       - name: Success
#         run: |
#           echo "üéâ Frontend CI passed!"
#           echo "‚úÖ Docker image built successfully"
#           echo "‚úÖ Container started and served content"
#           echo "‚úÖ Ready for deployment!"
#         # What this does:
#         # - Just prints a success message
#         # - Only runs if all previous steps passed
#         # - Shows up in the GitHub Actions logs

# # ============================================
# # WHAT HAPPENS IN REAL LIFE:
# # ============================================
# # 
# # 1. You change frontend/src/Home.jsx
# # 2. You run: git push origin feature/docker-containerization
# # 3. GitHub sees the push
# # 4. GitHub checks: "Did frontend/** files change?" ‚Üí Yes!
# # 5. GitHub Actions starts this workflow
# # 6. Spins up a fresh Ubuntu machine
# # 7. Downloads your code
# # 8. Installs Docker
# # 9. Builds your frontend Docker image
# # 10. Starts the container
# # 11. Tests if it serves content
# # 12. If all pass: ‚úÖ Shows green checkmark
# # 13. If any fail: ‚ùå Shows red X with error details
# #
# # ============================================
# # WHY THIS IS USEFUL:
# # ============================================
# #
# # ‚úÖ Catches errors BEFORE deploying to production
# # ‚úÖ Tests on a clean machine (not just "works on my computer")
# # ‚úÖ Automatic - no manual testing needed
# # ‚úÖ Every team member sees if their changes break things
# # ‚úÖ Can't merge broken code to main (if you set up branch protection)
# #
# # ============================================



# ============================================
# FRONTEND CI WORKFLOW - WITH REAL SECRETS
# Tests: Build with Real Supabase URLs ‚Üí Container Starts ‚Üí Serves Content
# ============================================

name: Frontend CI

on:
  push:
    branches: [ main, develop, feature/** ]
    paths:
      - 'frontend/**'
      - '.github/workflows/frontend-ci.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'frontend/**'

jobs:
  # ============================================
  # JOB 1: BUILD WITH REAL SUPABASE CONFIG
  # ============================================
  build-and-test:
    name: Build & Test Frontend
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        # Downloads your code from GitHub
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        # Installs Docker with advanced features
      
      - name: Build frontend with real Supabase URLs
        run: |
          cd frontend
          docker build \
            --build-arg VITE_SUPABASE_URL="${{ secrets.VITE_SUPABASE_URL }}" \
            --build-arg VITE_SUPABASE_ANON_KEY="${{ secrets.VITE_SUPABASE_ANON_KEY }}" \
            --build-arg VITE_API_URL="http://backend:8000" \
            -t pitchquest-frontend:${{ github.sha }} .
          
          docker tag pitchquest-frontend:${{ github.sha }} pitchquest-frontend:latest
        # What this does:
        # - Builds frontend Docker image
        # - Passes REAL Supabase URLs as build arguments
        # - These get baked into the Vite build
        # - Tags with commit SHA for version tracking
        #
        # Why use secrets here?
        # ‚úÖ Frontend needs Supabase URL at BUILD time (not runtime)
        # ‚úÖ Vite embeds environment variables during build
        # ‚úÖ Using real URLs ensures auth will work in production
      
      - name: Test Docker image starts
        run: |
          # Start container
          docker run -d --name test-frontend -p 3000:80 \
            pitchquest-frontend:latest
          
          # Check if running
          echo "‚è≥ Waiting for nginx to start..."
          sleep 10
          
          # Verify container is running
          if ! docker ps | grep test-frontend; then
            echo "‚ùå Container stopped! Logs:"
            docker logs test-frontend
            docker rm test-frontend
            exit 1
          fi
          
          echo "‚úÖ Container is running"
      
      - name: Test frontend serves content
        run: |
          echo "üß™ Testing if frontend serves HTML..."
          
          # Fetch homepage
          RESPONSE=$(curl -s http://localhost:3000)
          
          # Check if we got HTML content
          if echo "$RESPONSE" | grep -q "<!doctype html"; then
            echo "‚úÖ Frontend serving HTML!"
          else
            echo "‚ùå Frontend not serving HTML. Response:"
            echo "$RESPONSE"
            docker logs test-frontend
            exit 1
          fi
      
      - name: Test frontend assets load
        run: |
          echo "üß™ Testing if CSS/JS assets are accessible..."
          
          # Check if index.html references assets
          curl -s http://localhost:3000 | grep -o 'src="[^"]*"' | head -3
          curl -s http://localhost:3000 | grep -o 'href="[^"]*"' | head -3
          
          echo "‚úÖ Assets referenced in HTML"
        # This verifies the Vite build produced valid output
      
      - name: Show build info
        run: |
          echo "üì¶ Frontend build information:"
          docker exec test-frontend ls -lh /usr/share/nginx/html/
          echo ""
          echo "üîç Build includes:"
          docker exec test-frontend find /usr/share/nginx/html -type f | head -10
      
      - name: Show container logs
        if: always()
        run: |
          echo "üìã Nginx logs:"
          docker logs test-frontend
      
      - name: Cleanup
        if: always()
        run: |
          docker stop test-frontend || true
          docker rm test-frontend || true
      
      - name: Save Docker image
        if: github.ref == 'refs/heads/main'
        run: |
          docker save pitchquest-frontend:latest | gzip > frontend-image.tar.gz
      
      - name: Upload artifact
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: frontend-docker-image
          path: frontend-image.tar.gz
          retention-days: 1

  # ============================================
  # JOB 2: CI SUCCESS SUMMARY
  # ============================================
  ci-complete:
    name: Frontend CI Complete
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
      - name: Success summary
        run: |
          echo "üéâ Frontend CI Complete!"
          echo ""
          echo "‚úÖ Build with real Supabase URLs - Passed"
          echo "‚úÖ Docker container starts - Passed"
          echo "‚úÖ Nginx serves content - Passed"
          echo "‚úÖ Assets compiled correctly - Passed"
          echo ""
          echo "üöÄ Frontend ready for deployment!"

# ============================================
# WHAT THIS TESTS:
# ============================================
#
# Build Phase:
#   ‚úÖ npm ci works (dependencies install)
#   ‚úÖ npm run build works (Vite compiles successfully)
#   ‚úÖ Supabase URLs are valid format
#   ‚úÖ No build errors
#
# Container Phase:
#   ‚úÖ Nginx starts correctly
#   ‚úÖ Static files served
#   ‚úÖ Routing configured properly
#
# What it DOESN'T test:
#   ‚ùå Actual Supabase authentication (needs browser)
#   ‚ùå Frontend ‚Üí Backend API calls (needs both running)
#   ‚ùå User interactions (needs E2E tests)
#
# These are tested in staging environment
# ============================================